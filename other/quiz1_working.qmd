---
title: "Trying out Model"
author: Jonathan A. Pedroza
format:
  html:
    toc: true
    toc-depth: 2
    grid:
      #sidebar-width: 0px
      body-width: 1300px
      #margin-width: 0px
      gutter-width: 1.5rem
    theme: lumen
    code-fold: true
jupyter: python3
execute:
  echo: true
  eval: true
  warning: false
  message: false
params:
---

```{python}
import pandas as pd
import numpy as np
from scipy import stats
from janitor import clean_names
from pyhere import here
import os

att_names = pd.read_csv(here('data/q_matrix/Latent Attributes/quiz1_att_names.csv'))
```

```{python}
#| tags: [parameters]

jpcolor = 'seagreen'
# quiz_num = 'quiz1'
# irt_num = '1'
# lcdm #bayes_net_lcdm_linear # dina_bn # bayes_net_dina_linear
# stan file name
dcm_type = 'quiz1_model' 
mastery_prob = .8
prof_prob = .5
att1_name = att_names.loc[0, 'attribute']
att2_name = att_names.loc[1, 'attribute']
att3_name = att_names.loc[2, 'attribute']
att4_name = att_names.loc[3, 'attribute']
att5_name = att_names.loc[4, 'attribute']
data_path = 'other/item_responses_200x11.csv'
qmatrix_path = 'other/q_matrix_11_items_5_attributes.csv'
```

```{python}
import plotnine as pn
import matplotlib
import matplotlib.pyplot as plt
import arviz as az
import joblib
from cmdstanpy import CmdStanModel
from great_tables import GT as gt
import plotly.express as px
import plotly.io as pio

os.environ['QT_API'] = 'PyQt6'
pd.set_option('display.max_columns', None)
pd.options.mode.copy_on_write = True
matplotlib.rcParams.update({'savefig.bbox': 'tight'})
pn.theme_set(pn.theme_light())
# pio.templates.default = 'simple_white' # 'plotly_white'

def overall_ppp(df, stat):
    thresh = np.array(y_describe.loc[y_describe['index'] == stat, 'item1':'item10'].mean(axis = 1))[0]
    cond = df.loc[:, stat] > thresh
    ppp_val = np.where(cond, 1, 0).mean()
    return ppp_val

def ppp_func(df, item_num, stat):
    thresh = np.array(y_describe.loc[y_describe['index'] == stat, f'item{item_num}'])[0]
    cond = df.loc[df['item'] == item_num, stat] > thresh
    ppp_val = np.where(cond, 1, 0).mean()
    return ppp_val

def q_lower(x):
    return x.quantile(.025)
  
def q_upper(x):
    return x.quantile(.975)
```

```{python}
# attribute mastery matrix
alpha = pd.DataFrame([(a, b, c, d, e) for a in np.arange(2) for b in np.arange(2) for c in np.arange(2) for d in np.arange(2) for e in np.arange(2)])
alpha = alpha.rename(columns = {0: att1_name,
                                1: att2_name,
                                2: att3_name,
                                3: att4_name,
                                4: att5_name}).clean_names(case_type = 'snake')
```

```{python}
y = pd.read_csv(here(f'{data_path}'))
y_col = y.columns.str.replace('_', '')
y.columns = y_col
y.head()
```

```{python}
q = pd.read_csv(here(f'{qmatrix_path}')).clean_names(case_type = 'snake').drop(columns = 'item')
q_col = q.columns.str.replace('attribute_', 'att')
q.columns = q_col
q.head()
```

```{python}
name_mapping = {'y_rep': 'Y'}

stan_dict = {
  'J': y.shape[0],
  'I': y.shape[1],
  'C': alpha.shape[0],
  'K': q.shape[1],
  'Y': np.array(y),
  'Q': np.array(q),
  'alpha': np.array(alpha)
}

y_describe = y.filter(regex = 'item').agg(['mean', 'std']).reset_index()
y_describe.drop(columns = 'index').transpose()
actual_avg = y_describe.loc[y_describe['index'] == 'mean', 'item1':'item10'].mean(axis = 1)[0]
```

# DCM/Bayes Net

```{python}
dcm_file = os.path.join(here(f'quiz_models/{dcm_type}.stan'))
dcm_model = CmdStanModel(stan_file = dcm_file,
                         cpp_options={'STAN_THREADS': 'TRUE'})

np.random.seed(12345)
dcm_fit = dcm_model.sample(data = stan_dict,
                        show_console = True,
                        chains = 4,
                        # adapt_delta = .95,
                        iter_warmup = 2000,
                        iter_sampling = 2000)

dcm_diagnose = pd.DataFrame(dcm_fit.summary())
```

## Saving Model

```{python}
#| eval: false
#| echo: true

dcm_diagnose.to_csv(here(f'diagnostics/{dcm_type}_{quiz_num}.csv'))

(
  joblib.dump([dcm_model, dcm_fit],
              here(f'joblib_models/{dcm_type}_{quiz_num}_modfit.joblib'),
              compress = 3)
)
```

```{python}
dcm_prior_file = os.path.join(here(f'quiz_models/{dcm_type}_prior_only.stan'))
dcm_prior_model = CmdStanModel(stan_file = dcm_prior_file,
                         cpp_options={'STAN_THREADS': 'TRUE'})

np.random.seed(12345)
dcm_prior_fit = dcm_prior_model.sample(data = stan_dict,
                        show_console = True,
                        chains = 4,
                        # adapt_delta = .95,
                        iter_warmup = 2000,
                        iter_sampling = 2000)

dcm_prior_diagnose = pd.DataFrame(dcm_prior_fit.summary())
```

## Saving Priors From Model

```{python}
#| eval: false
#| echo: true

dcm_prior_diagnose.to_csv(here(f'diagnostics/{dcm_type}_{quiz_num}_prior_only.csv'))

(
  joblib.dump([dcm_prior_model, dcm_prior_fit],
              here(f'joblib_models/{dcm_type}_{quiz_num}_modfit_prior_only.joblib'),
              compress = 3)
)
```

```{python}
print(dcm_prior_diagnose['R_hat'].sort_values(ascending = False).head())
print(dcm_diagnose['R_hat'].sort_values(ascending = False).head())
```

```{python}
idcm = az.from_cmdstanpy(
    posterior = dcm_fit,
    posterior_predictive = ['y_rep'],
    observed_data = {'Y': y.filter(regex = 'item')}
    # log_likelihood = {'Y': 'eta'}
    )

idcm = idcm.rename(name_dict = name_mapping, groups = ["posterior_predictive"])

idcm_prior = az.from_cmdstanpy(prior = dcm_prior_fit,
prior_predictive = ['y_rep'])

idcm_prior = idcm_prior.rename(
    name_dict = name_mapping,
    groups = ['prior_predictive']
)

idcm.extend(idcm_prior)
```

# Plotting Distributions

## Comparing Prior to Posterior Distributions

```{python}
az.plot_dist_comparison(idcm, var_names = ['theta1'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['theta2'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['theta3'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['theta4'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['theta5'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['gamma20'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['gamma21'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['gamma30'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['gamma31'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['delta'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['pi'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['nu'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['tp'])
plt.show()
```

```{python}
az.plot_dist_comparison(idcm, var_names = ['fp'])
plt.show()
```

## Examining Trace Plots

```{python}
az.plot_trace(idcm, var_names = 'nu')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'pi')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'delta')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'theta1')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'theta2')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'theta3')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'theta4')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = 'theta5')
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = ['gamma20', 'gamma21'])
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = ['gamma30', 'gamma31'])
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = ['tp'])
plt.show()
```

```{python}
az.plot_trace(idcm, var_names = ['fp'])
plt.show()
```

```{python}
az.plot_forest(idcm, var_names = 'prob_joint')
plt.show()
```

## Attribute Mastery Per Class Visual

```{python}
az.plot_forest(idcm.posterior["prob_resp_class"].isel(prob_resp_class_dim_0 = slice(0, 4),
                                                    prob_resp_class_dim_1 = slice(None)
                                                    ),
               var_names = 'prob_resp_class',
               colors = jpcolor)
plt.show()
```

## Attribute Mastery Per Student Visual

```{python}
az.plot_forest(idcm.posterior["prob_resp_attr"].isel(prob_resp_attr_dim_0 = slice(0, 10),
                                                    prob_resp_attr_dim_1 = slice(None)
                                                    ),
               var_names = 'prob_resp_attr',
               colors = jpcolor)
plt.show()
```

# Model Fit

```{python}
az.loo(idcm)
```

```{python}
az.waic(idcm)
```

## PPP Visuals

```{python}
az.plot_ppc(idcm,
            data_pairs = {'Y': 'Y'},
            num_pp_samples = 1000)
plt.show()
# plt.clf()
```

```{python}
az.plot_ppc(idcm,
            data_pairs = {'Y': 'Y'},
            num_pp_samples = 1000,
            kind = 'cumulative')
plt.show()
# plt.clf()
```

```{python}
az.plot_bpv(idcm,
            kind = 't_stat', 
            t_stat = 'mean')
plt.show()
# plt.clf()
```

```{python}
az.plot_bpv(idcm,
            kind = 't_stat', 
            t_stat = 'std')
plt.show()
# plt.clf()
```

# Pandas Wrangling

```{python}
dcmdf = dcm_fit.draws_pd()
```

## Pi Matrix

```{python}
pi_mat = dcmdf.filter(regex = 'pi')
pi_mat = pd.DataFrame({
  'mean': pi_mat.mean(),
  'std': pi_mat.std(),
  'q_lower': q_lower(pi_mat),
  'q_upper': q_upper(pi_mat)
}).reset_index()

pi_mat['index'] = pi_mat['index'].str.replace('pi[', '')
pi_mat['index'] = pi_mat['index'].str.replace(']', '')
pi_mat[['item', 'lat_class']] = pi_mat['index'].str.split(',', expand = True)
pi_mat[['item', 'lat_class']] = pi_mat[['item', 'lat_class']].astype(int)
pi_mat = pi_mat[['item', 'lat_class', 'mean', 'std', 'q_lower', 'q_upper']]
pi_mat.head()

pn.ggplot.show(
  pn.ggplot(pi_mat,
            pn.aes('factor(item)',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                     alpha = .7,
                     color = jpcolor)
  + pn.geom_hline(yintercept = .5,
                  color = 'black',
                  linetype = 'dashed')
  + pn.coord_flip()
  + pn.facet_wrap('lat_class')
  + pn.labs(title = 'Probability That Latent Class Gets Items Correct',
            x = 'Item',
            y = 'Probability')
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(pi_mat,
            pn.aes('factor(item)',
                   'std'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.facet_wrap('lat_class')
  + pn.labs(title = 'Standard Deviation For Each Item By Latent Class',
            x = 'Item',
            y = 'Standard Deviation')
)
```

## Theta Coefficients

### `{python} att1_name` Attribute

```{python}
theta1_df = dcmdf.filter(regex = 'theta1')
theta1_df = pd.DataFrame({
  'mean': theta1_df.mean(),
  'std': theta1_df.std(),
  'q_lower': q_lower(theta1_df),
  'q_upper': q_upper(theta1_df)
}).reset_index()

pn.ggplot.show(
  pn.ggplot(theta1_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                            color = jpcolor,
                            alpha = .7)
  + pn.coord_flip()
  + pn.scale_y_continuous(limits = [0, 1],
  breaks = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  + pn.labs(x = 'Attribute Posterior',
            y = 'Probability')
)
```

### `{python} att2_name` Attribute

```{python}
theta2_df = dcmdf.filter(regex = 'theta2')
theta2_df = pd.DataFrame({
  'mean': theta2_df.mean(),
  'std': theta2_df.std(),
  'q_lower': q_lower(theta2_df),
  'q_upper': q_upper(theta2_df)
}).reset_index()

pn.ggplot.show(
  pn.ggplot(theta2_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                            color = jpcolor,
                            alpha = .7)
  + pn.coord_flip()
  + pn.scale_y_continuous(limits = [0, 1],
  breaks = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  + pn.labs(x = 'Attribute Posterior',
            y = 'Probability')
)
```

### `{python} att3_name` Attribute

```{python}
theta3_df = dcmdf.filter(regex = 'theta3')
theta3_df = pd.DataFrame({
  'mean': theta3_df.mean(),
  'std': theta3_df.std(),
  'q_lower': q_lower(theta3_df),
  'q_upper': q_upper(theta3_df)
}).reset_index()

pn.ggplot.show(
  pn.ggplot(theta3_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                            color = jpcolor,
                            alpha = .7)
  + pn.coord_flip()
  + pn.scale_y_continuous(limits = [0, 1],
  breaks = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  + pn.labs(x = 'Attribute Posterior',
            y = 'Probability')
)
```

### `{python} att4_name` Attribute

```{python}
theta4_df = dcmdf.filter(regex = 'theta4')
theta4_df = pd.DataFrame({
  'mean': theta4_df.mean(),
  'std': theta4_df.std(),
  'q_lower': q_lower(theta4_df),
  'q_upper': q_upper(theta4_df)
}).reset_index()

pn.ggplot.show(
  pn.ggplot(theta4_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                            color = jpcolor,
                            alpha = .7)
  + pn.coord_flip()
  + pn.scale_y_continuous(limits = [0, 1],
  breaks = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  + pn.labs(x = 'Attribute Posterior',
            y = 'Probability')
)
```

### `{python} att5_name` Attribute

```{python}
theta5_df = dcmdf.filter(regex = 'theta5')
theta5_df = pd.DataFrame({
  'mean': theta5_df.mean(),
  'std': theta5_df.std(),
  'q_lower': q_lower(theta5_df),
  'q_upper': q_upper(theta5_df)
}).reset_index()

pn.ggplot.show(
  pn.ggplot(theta5_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                            color = jpcolor,
                            alpha = .7)
  + pn.coord_flip()
  + pn.scale_y_continuous(limits = [0, 1],
  breaks = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  + pn.labs(x = 'Attribute Posterior',
            y = 'Probability')
)
```

## Gamma Coefficients

```{python}
gamma_df = dcmdf.filter(regex = 'gamma')
gamma_df = pd.DataFrame({
  'mean': gamma_df.mean(),
  'std': gamma_df.std(),
  'q_lower': q_lower(gamma_df),
  'q_upper': q_upper(gamma_df)
}).reset_index()

gamma_df.head()

pn.ggplot.show(
  pn.ggplot(gamma_df,
            pn.aes('index',
                   'mean'))
  + pn.geom_point(alpha = .7,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                     alpha = .7,
                     color = jpcolor)
  + pn.labs(title = 'Coefficient Value Per Variable',
            x = 'Attribute Baseline & Improvement',
            y = 'Coefficient')
)
```

## PPP Calculations

```{python}
ydcm = dcmdf.filter(regex = '^y_rep')

ydcm_prob = pd.DataFrame({
  'mean': ydcm.mean(),
  'std': ydcm.std(),
  'q_lower': q_lower(ydcm),
  'q_upper': q_upper(ydcm)
}).reset_index()

ydcm_prob['index'] = ydcm_prob['index'].str.replace('y_rep[', '')
ydcm_prob['index'] = ydcm_prob['index'].str.replace(']', '')
ydcm_prob[['stu', 'item']] = ydcm_prob['index'].str.split(pat = ',', expand = True)
ydcm_prob = ydcm_prob[['stu', 'item', 'mean', 'std', 'q_lower', 'q_upper']]
ydcm_prob[['stu', 'item']] = ydcm_prob[['stu', 'item']].astype(int)
ydcm_prob['correct'] = np.where(ydcm_prob['mean'] >= .5, 1, 0)

pn.ggplot.show(
  pn.ggplot(ydcm_prob,
            pn.aes('stu',
                   'mean'))
  + pn.geom_point(pn.aes(color = 'factor(item)'),
                  alpha = .5)
  # + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
  #                           ymax = 'q_upper',
  #                           color = 'factor(item)'),
  #                    alpha = .1)
  + pn.geom_hline(yintercept = .5,
                  color = 'black',
                  linetype = 'dashed')
  + pn.labs(title = 'Probability Student Gets Items Correct',
            x = 'Student',
            y = 'Probability')
  + pn.theme(axis_text_x = pn.element_blank())
)
```

```{python}
ydcm_wide = (
  ydcm_prob
  .pivot(
    index = 'stu',
    columns = 'item',
    values = 'correct')
  .reset_index(drop = True)
)

ydcm_wide.columns = [f'item{i+1}' for i in np.arange(ydcm_wide.shape[1])]
ydcm_wide = ydcm_wide.reset_index()
ydcm_wide = ydcm_wide.rename(columns = {'index': 'stu'})
ydcm_wide['stu'] = ydcm_wide['stu'] + 1
# ydcm_wide.head()
```

```{python}
ydcm_wide['total_correct'] = ydcm_wide.drop(columns = 'stu').sum(axis = 1)
ydcm_wide['actual_correct'] = y.sum(axis = 1)

ydcm_compare = ydcm_wide[['stu', 'total_correct', 'actual_correct']].melt(id_vars = 'stu')
ydcm_compare_count = ydcm_compare.groupby('variable')['value'].value_counts().reset_index()

pn.ggplot.show(
  pn.ggplot(ydcm_compare_count,
            pn.aes('factor(value)',
                   'count'))
  + pn.geom_col(pn.aes(fill = 'variable'),
                position = pn.position_dodge())
)
```

```{python}
ydcm_compare_actual = ydcm_compare.loc[ydcm_compare['variable'] == 'actual_correct', 'value'].sort_values()
ydcm_compare_predict = ydcm_compare.loc[ydcm_compare['variable'] == 'total_correct', 'value'].sort_values()

ydcm_compare_actual = pd.Categorical(ydcm_compare_actual, ordered = True)
ydcm_compare_predict = pd.Categorical(ydcm_compare_predict, ordered = True)


count_tabs = pd.crosstab(ydcm_compare_actual,
                         ydcm_compare_predict)
# count_tabs

# from scipy.stats import chisquare
from scipy.stats import chi2_contingency
chi2_contingency(observed = count_tabs)
```

### Overall PPP Values

```{python}
overall_ppp(ydcm_prob, 'mean')
```

```{python}
# overall, model fits pretty well

overall_ppp(ydcm_prob, 'std')
```

### Item Specific PPP Values

```{python}
dcm_means = [ppp_func(df = ydcm_prob,
                      item_num = i,
                      stat = 'mean') for i in np.arange(1,
                                                        (y_describe.shape[1]))]
dcm_stds = [ppp_func(df = ydcm_prob,
                     item_num = i,
                     stat = 'std') for i in np.arange(1,
                                                      (y_describe.shape[1]))]

ppp_dcm = pd.DataFrame({'means': pd.Series(dcm_means),
                       'stds': pd.Series(dcm_stds)})

ppp_dcm = ppp_dcm.reset_index()
ppp_dcm = ppp_dcm.rename(columns = {'index': 'item'})
ppp_dcm['item'] = ppp_dcm['item'] + 1

gt.show(gt(ppp_dcm))
```

```{python}
pn.ggplot.show(
  pn.ggplot(ppp_dcm, pn.aes('item', 'means'))
  + pn.geom_point(color = jpcolor,
                  size = 2)
  + pn.geom_hline(yintercept = .5, linetype = 'dashed')
  + pn.geom_hline(yintercept = .025, linetype = 'dotted')
  + pn.geom_hline(yintercept = .975, linetype = 'dotted')
  + pn.scale_x_continuous(limits = [1, ppp_dcm['item'].max() + 1],
                          breaks = np.arange(1, ppp_dcm['item'].max() + 1))
  + pn.scale_y_continuous(limits = [0, 1.01],
                          breaks = np.arange(0, 1.01, .1))
  + pn.theme_light()
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(ppp_dcm, pn.aes('item', 'stds'))
  + pn.geom_point(color = jpcolor,
                  size = 2)
  + pn.geom_hline(yintercept = .5, linetype = 'dashed')
  + pn.geom_hline(yintercept = .025, linetype = 'dotted')
  + pn.geom_hline(yintercept = .975, linetype = 'dotted')
  + pn.scale_x_continuous(limits = [1, ppp_dcm['item'].max() + 1],
                          breaks = np.arange(1, ppp_dcm['item'].max() + 1))
  + pn.scale_y_continuous(limits = [0, 1.01],
                          breaks = np.arange(0, 1.01, .1))
  + pn.theme_light()
)
```

## Attribute Mastery & Uncertainty

```{python}
attr_df = dcmdf.filter(regex = '^prob_resp_attr')
attr_df = pd.DataFrame({
  'mean': attr_df.mean(),
  'std': attr_df.std(),
  'q_lower': q_lower(attr_df),
  'q_upper': q_upper(attr_df)
}).reset_index()

attr_df['index'] = attr_df['index'].str.replace('prob_resp_attr[', '')
attr_df['index'] = attr_df['index'].str.replace(']', '')
attr_df[['stu', 'attr']] = attr_df['index'].str.split(',', expand = True)
attr_df[['stu', 'attr']] = attr_df[['stu', 'attr']].astype(int)
attr_df = attr_df[['stu', 'attr', 'mean', 'std', 'q_lower', 'q_upper']]
# attr_df.head()

pn.ggplot.show(
  pn.ggplot(attr_df,
            pn.aes('stu',
                   'mean'))
  + pn.geom_point(alpha = .5,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                     alpha = .1)
  + pn.geom_hline(yintercept = mastery_prob,
                  linetype = 'dashed')
  + pn.facet_wrap('attr')
  + pn.labs(title = 'Attribute Mastery Per Student',
            x = 'Students',
            y = 'Probability')
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(attr_df,
            pn.aes('stu',
                   'std'))
  + pn.geom_point(alpha = .5,
                  color = jpcolor)
  + pn.facet_wrap('attr')
  + pn.labs(title = 'Standard Deviation Per Student For Each Attribute',
            x = 'Students',
            y = 'Standard Deviation')
)
```

```{python}
attr_df['mastery'] = np.where(attr_df['mean'] > mastery_prob, 1, 0)
attr_df['proficiency'] = np.where(attr_df['mean'] > prof_prob, 1, 0)

# attr_df.head()

print(attr_df.groupby('attr')['mastery'].value_counts().reset_index())
print('\n\n')
print(attr_df.groupby('attr')['proficiency'].value_counts().reset_index())
```

```{python}
attr_mastery = attr_df.pivot(index = 'stu',
              columns = 'attr',
              values = 'mastery').reset_index()
attr_mastery = attr_mastery.rename(columns = {1: 'attr1',
                                              2: 'attr2',
                                              3: 'attr3',
                                              4: 'attr4',
                                              5: 'attr5'})
# attr_mastery.head()
```

```{python}
#| eval: true
#| echo: true

attr_mastery['attr1'] = np.where(attr_mastery['attr1'] == 1, f'Proficient in {att1_name}', f'Did not meet proficiency of {att1_name}')

attr_mastery['attr2'] = np.where(attr_mastery['attr2'] == 1, f'Proficient in {att2_name}', f'Did not meet proficiency of {att2_name}')

attr_mastery['attr3'] = np.where(attr_mastery['attr3'] == 1, f'Proficient in {att3_name}', f'Did not meet proficiency of {att3_name}')

attr_mastery['attr4'] = np.where(attr_mastery['attr4'] == 1, f'Proficient in {att4_name}', f'Did not meet proficiency of {att4_name}')

attr_mastery['attr5'] = np.where(attr_mastery['attr5'] == 1, f'Proficient in {att5_name}', f'Did not meet proficiency of {att5_name}')

attr_mastery.to_csv(here(f'student_data/attribute_mastery_{quiz_num}.csv'))
print(attr_mastery.head())
```

## Attribute Mastery Per Class

```{python}
attr_class_df = dcmdf.filter(regex = '^prob_resp_class')
attr_class_df = pd.DataFrame({
  'mean': attr_class_df.mean(),
  'std': attr_class_df.std(),
  'q_lower': q_lower(attr_class_df),
  'q_upper': q_upper(attr_class_df)
}).reset_index()

attr_class_df['index'] = attr_class_df['index'].str.replace('prob_resp_class[', '')
attr_class_df['index'] = attr_class_df['index'].str.replace(']', '')
attr_class_df[['stu', 'lat_class']] = attr_class_df['index'].str.split(',', expand = True)
attr_class_df[['stu', 'lat_class']] = attr_class_df[['stu', 'lat_class']].astype(int)
attr_class_df = attr_class_df[['stu', 'lat_class', 'mean', 'std', 'q_lower', 'q_upper']]
# attr_class_df.head()

pn.ggplot.show(
  pn.ggplot(attr_class_df,
            pn.aes('stu',
                   'mean'))
  + pn.geom_point(alpha = .5,
                  color = jpcolor)
  + pn.geom_errorbar(pn.aes(ymin = 'q_lower',
                            ymax = 'q_upper'),
                     alpha = .1)
  + pn.facet_wrap('lat_class')
  + pn.labs(title = 'Probability Per Student In Each Latent Class',
            x = 'Students',
            y = 'Probability')
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(attr_class_df,
            pn.aes('stu',
                   'std'))
  + pn.geom_point(alpha = .5,
                  color = jpcolor)
  + pn.facet_wrap('lat_class')
  + pn.labs(title = 'Standard Deviation Per Student For Each Latent Class',
            x = 'Students',
            y = 'Standard Deviation')
)
```
